---
title: 组件传值
date: 2022-02-09 09:13:35
permalink: /pages/af6493/
categories:
  - docs
  - vue
  - 组件
tags:
  - 
---
# 组件传值

## 父组件传值给子组件

### 基本用法

1. 父组件中，通过给子组件标签 v-bind 绑定属性的方式传入值。如果不使用 v-bind 传入的值为字符串，使用 v-bind 绑定传入的值为表达式。

```html
<!-- 传入字符串 -->
<ComponentName name="value"></ComponentName>
<!-- 传入表达式 -->
<ComponentName :name="value"></ComponentName>
```

2. 子组件中，通过 props 对象接收值

```js
 props: {
    name: { // 接收父组件传入值
        type: String || ...,
        default: ''
    }
 }
```

### 属性(单向数据流)

> 所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态。
> **子组件不能直接修改父组件传入的值** > **demo**

1. prop 用来传递一个初始值,子组件希望将其作为一个本地的 prop 数据来使用,则定义一个本地的 data 属性并将这个 prop 用作其初始值：

```js
props: ['initialCounter'],
data: function () {
  return {
    counter: this.initialCounter
  }
}
```

2. prop 以原始的值传入且需要进行转换，则使用这个 prop 的值来定义一个计算属性：

```js
props: ['size'],
computed: {
  normalizedSize: function () {
    return this.size.trim().toLowerCase()
  }
}
```

## 子组件派发事件和值给父组件

### 基本用法

1. 子组件中，通过`$emit`派发事件和值给父组件（值可以有多个）。

```js
this.$emit("fnX");
```

2. 父组件中，通过`v-on`绑定子组件派发的事件，并触发一个新的事件，新的事件内可以接收传来的值。

```html
<template>
<ComponentName @fnX="fnY"/></ComponentName>
</template>
<script>
    export default {
    components:{
      ComponentName
    }
    methods: {
	fnY(value) {
	}
}
    }
</script>
```

## 父组件调用子组件方法并传入值

> 通过`ref`引用调用子组件内的方法并传入参数

### 基本用法

1. 父组件中:

```js
<子组件标签  ref="refName"></子组件标签>

methods: {
    fnX(x) {
      this.$refs.refName.fnY(x) // 调用子组件方法并传入值
    }
}
```

2. 子组件中

```js
methods: {
    fnY(x) {
      this.x = x
    }
  }

```

## 非父子组件间传值(eventBus)

### 定义

> 使用 eventBus 方法实现父子组件、兄弟组件、多层嵌套组件间的通讯

### 流程

1. 初始化——全局定义。
   将 eventBus 挂在到 vue 实例的原型上。
   在 main.js 文件中,注册全局方法`Vue.prototype.$EventBus = new Vue()`;

2. 监听事件。
   在需要接收的页面进行监听

```html
<script>
    export default {
    created(){
    this.$EventBus.$on('eventName', (param1,param2,...)=>{
      //需要执行的代码
  })
  }
    }
</script>
```

3. 触发事件。
   在需要出发监听的页面抛出这个事件
   `this.$EventBus.$emit('eventName')`

4. 移除监听事件。
   为了避免在监听时，事件被反复触发，通常需要在页面销毁时移除事件监听。或者由于热更新，事件可能会被多次绑定监听，这时也需要移除事件监听。

```html
<script>
  export default {
    beforeDestroy() {
      this.$EventBus.$off("eventName");
    },
  };
</script>
```

### 注意事项

-移除监听事件与监听事件成对出现。
-定义不同的事件名须不同
